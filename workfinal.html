<!DOCTYPE html>
<html lang="th">

<head>
  <meta charset="utf-8">
  <title>WorKfinalv1</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>

<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dat.gui/build/dat.gui.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>

  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(5, 3, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const gui = new dat.GUI();

    // Floor
    const texLoader = new THREE.TextureLoader();
    const floorTexture = texLoader.load('https://demotype.github.io/GPU/moon_footprints_02_diff_1k.jpg');
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(8, 8);
    const plane = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), new THREE.MeshStandardMaterial({ map: floorTexture, metalness: 0.1, roughness: 0.8 }));
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // ðŸ”¸ à¹à¸ªà¸‡
    const directionalLight = new THREE.DirectionalLight(0xffeedd, 0.9);
    directionalLight.position.set(10, 5, 10);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0xffeedd, 1);
    pointLight.position.set(8, 0, -5);
    pointLight.castShadow = true;
    scene.add(pointLight);

    // ðŸ”¸ GUI à¹à¸ªà¸‡
    const lightFolder = gui.addFolder('Lights');
    lightFolder.add(directionalLight, 'intensity', 0, 2);
    lightFolder.add(pointLight, 'intensity', 0, 2);
    // HDRI
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    new THREE.RGBELoader()
      .setDataType(THREE.UnsignedByteType)
      .load('https://raw.githubusercontent.com/DemoTYPE/GPU/main/assets/HDRi/qwantani_moon_noon_puresky_1k.hdr', (hdr) => {
        const envMap = pmremGenerator.fromEquirectangular(hdr).texture;
        scene.background = envMap;
        scene.environment = envMap;
        hdr.dispose();
        pmremGenerator.dispose();
      });

    // Load models
    let monowheel;
    const gltfLoader = new THREE.GLTFLoader();
    gltfLoader.load('https://demotype.github.io/GPU/monowheel_bot__vgdc.glb', (gltf) => {
      monowheel = gltf.scene;
      monowheel.scale.set(0.1, 0.1, 0.1);      // à¸‚à¸™à¸²à¸”
      monowheel.rotation.set(0, 1, 0);
      monowheel.traverse(c => { if (c.isMesh) { c.castShadow = c.receiveShadow = true; } });
      scene.add(monowheel);
    });

    gltfLoader.load('https://demotype.github.io/GPU/low_poly_game_ready_kfc.glb', (gltf) => {
      const model1 = gltf.scene;
      model1.position.set(2.5, 0, -2);   // à¸•à¸³à¹à¸«à¸™à¹ˆà¸‡
      model1.scale.set(0.4, 0.4, 0.4);      // à¸‚à¸™à¸²à¸”
      model1.rotation.set(0, 1, 0);
      model1.traverse(c => { if (c.isMesh) { c.castShadow = c.receiveShadow = true; } });
      scene.add(model1);
    });

    gltfLoader.load('https://demotype.github.io/GPU/KUMEv2.glb', (gltf) => {
      const modelku = gltf.scene;
      modelku.position.set(5.9,1.68, -1.5);   // à¸•à¸³à¹à¸«à¸™à¹ˆà¸‡
      modelku.scale.set(1.5, 1.5, 1.5);      // à¸‚à¸™à¸²à¸”
      modelku.rotation.set(0, 1, 0);
      modelku.traverse(c => { if (c.isMesh) { c.castShadow = c.receiveShadow = true; } });
      scene.add(modelku);
    });

    // Camera preset
    const cameraTarget = new THREE.Vector3(0, 2, 4);
    const cameraLookTarget = new THREE.Vector3(0, 1, 0);
    const views = {
      Default: { pos: new THREE.Vector3(0, 2, 4), look: new THREE.Vector3(0, 1, 0) },
      KFC_View: { pos: new THREE.Vector3(2, 3, 6), look: new THREE.Vector3(2.5, 0.8, -2) },
      Monowheel_View: { pos: new THREE.Vector3(-4, 2.5, 1), look: new THREE.Vector3(-2, 0.5, 0) },
      KU_View: { pos: new THREE.Vector3(8.5,2.8, -1), look: new THREE.Vector3(3.4, 1, -3.4) }
    };
    const camFolder = gui.addFolder('Camera Views');
    const camControls = {
      View_Default: () => { cameraTarget.copy(views.Default.pos); cameraLookTarget.copy(views.Default.look); },
      View_KFC: () => { cameraTarget.copy(views.KFC_View.pos); cameraLookTarget.copy(views.KFC_View.look); },
      View_Monowheel: () => { cameraTarget.copy(views.Monowheel_View.pos); cameraLookTarget.copy(views.Monowheel_View.look); },
      View_KU: () => { cameraTarget.copy(views.KU_View.pos); cameraLookTarget.copy(views.KU_View.look); }
    };
    camFolder.add(camControls, 'View_Default').name('Default');
    camFolder.add(camControls, 'View_KFC').name('KFC');
    camFolder.add(camControls, 'View_Monowheel').name('Monowheel');
    camFolder.add(camControls, 'View_KU').name('KU');
    camFolder.open();

    // Monowheel circular motion variables
    let angle = 0;
    const radius = 1.25;
    const center = new THREE.Vector3(-2, 0, 0); // à¸ˆà¸¸à¸”à¸à¸¶à¹ˆà¸‡à¸à¸¥à¸²à¸‡à¸§à¸‡à¸à¸¥à¸¡

    // Camera follow on click
    let followMonowheel = false;
    const cameraOffset = new THREE.Vector3(2, 1.5, 2);
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    window.addEventListener('click', (event) => {
      if (!monowheel) return;
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObject(monowheel, true);
      if (intersects.length > 0) {
        followMonowheel = !followMonowheel; // à¸„à¸¥à¸´à¸à¸ªà¸¥à¸±à¸šà¸•à¸´à¸”à¸•à¸²à¸¡
      }
    });

    // Lerp helper
    function lerp(a, b, t) { return a + (b - a) * t; }

    // Animate
    function animate() {
      if (monowheel) {
        angle += 0.01;
        const x = center.x + Math.cos(angle) * radius;
        const z = center.z + Math.sin(angle) * radius;
        const y = 0; // à¸„à¸§à¸²à¸¡à¸ªà¸¹à¸‡
        const prevPos = monowheel.position.clone();
        monowheel.position.lerp(new THREE.Vector3(x, y, z), 0.1);

        // à¸«à¸¡à¸¸à¸™ Monowheel à¸•à¸²à¸¡à¸à¸²à¸£à¹€à¸„à¸¥à¸·à¹ˆà¸­à¸™à¸—à¸µà¹ˆ
        const delta = monowheel.position.clone().sub(prevPos);
        if (delta.length() > 0.001) {
          const targetRot = Math.atan2(delta.x, delta.z);
          monowheel.rotation.y = lerp(monowheel.rotation.y, targetRot, 0.1);
        }
      }

      // à¸à¸¥à¹‰à¸­à¸‡à¸•à¸²à¸¡ Monowheel
      if (followMonowheel && monowheel) {
        const desiredPos = monowheel.position.clone().add(cameraOffset);
        cameraTarget.lerp(desiredPos, 0.05);
        cameraLookTarget.lerp(monowheel.position, 0.05);
      }

      // à¸à¸¥à¹‰à¸­à¸‡ lerp à¸•à¸²à¸¡ preset
      camera.position.lerp(cameraTarget, 0.01);
      controls.target.lerp(cameraLookTarget, 0.01);
      controls.update();

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>
